package analysis

import (
	"github.com/llir/llvm/ir/constant"
	"github.com/llir/llvm/ir/types"
)

func init_analysis(program *Program) error {
	for _, expr := range program.Expression {
		analyse(expr)
	}

	return nil
}

const (
	Nat = iota
	Real
	Str
	Char
	Bool
	Void
	Noun
)

type Block struct {
	expr   []*Expr
	oftype int // iota
}

type Expr struct {
	oftype int // iota
	app    *App
	atom   *Atom
}

type App struct {
	oftype  int // iota
	fortype int //iota
	op      string
	atoms   []*Atom
}

type Atom struct {
	oftype int // iota
	Nat    *int64
	Real   *float64
	String *string
	Noun   *string
	Bool   *bool
	Nil    bool
}

func analyse_is_number(atom Atom) bool {
	return atom.oftype == Nat || atom.oftype == Real
}

func analyse(expr *Expression) Expr {
	if a := expr.Application; a != nil {
		switch a.Op {
		case "return":
			entry.NewRet(gen(a.Atoms[0]))
		case "global":
			temp := gen(a.Atoms[1])
			glob := module.NewGlobal(*a.Atoms[0].Primary.Noun, temp.Type())
			entry.NewStore(temp, glob)
			return entry.NewLoad(temp.Type(), glob)
		case "add":
			return App{Real, Real, "add"}
		case "sub":
			lhs := gen(a.Atoms[0])
			if !val_is_number(lhs) {
				panic("sub: arg[0] must be number")
			}

			rhs := gen(a.Atoms[1])
			if !val_is_number(rhs) {
				panic("sub: arg[1] must be number")
			}

			return entry.NewSub(lhs, rhs)
		case "mul":
			lhs := gen(a.Atoms[0])
			if !val_is_number(lhs) {
				panic("mul: arg[0] must be number")
			}

			rhs := gen(a.Atoms[1])
			if !val_is_number(rhs) {
				panic("mul: arg[1] must be number")
			}

			return entry.NewMul(lhs, rhs)
		case "div":
			lhs := gen(a.Atoms[0])
			if !val_is_number(lhs) {
				panic("div: arg[0] must be number")
			}

			rhs := gen(a.Atoms[1])
			if !val_is_number(rhs) {
				panic("div: arg[1] must be number")
			}

			return entry.NewFDiv(lhs, rhs)
		}
	} else if p := expr.Primary; p != nil {
		switch {
		case p.Real != nil:
			return constant.NewFloat(types.Double, *p.Real)
		case p.Nat != nil:
			return constant.NewInt(types.I32, int64(*p.Nat))
		case p.String != nil:
			return constant.NewCharArrayFromString(*p.String)
		case p.Noun != nil:
			/* todo */
			return nil
		case p.Bool != nil:
			return constant.NewBool(*p.Bool)
		default:
			return constant.NewNull(types.I32Ptr)
		}
	}

	return nil
}
